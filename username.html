<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>그림 저장하기</title>
<style>
body {
  background: #111;
  color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  margin: 0;
}
canvas {
  border: 1px solid #fff;
  background: #222;
  cursor: crosshair;
  touch-action: none; /* 터치스크롤 방지 */
}
.controls {
  margin-top: 20px;
  display: flex;
  gap: 10px;
  align-items: center;
}
button {
  padding: 10px 20px;
  font-size: 16px;
  background: #4caf50;
  border: none;
  border-radius: 4px;
  color: white;
  cursor: pointer;
}
button:hover {
  background: #45a049;
}
label {
  font-size: 14px;
}
</style>
</head>
<body>

<canvas id="canvas" width="300" height="300"></canvas>
<div class="controls">
  <label for="colorPicker">선 색상:</label>
  <input type="color" id="colorPicker" value="#ffffff">
  <button id="saveButton">그림 저장하기</button>
</div>

<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let drawing = false;
let lastX = 0;
let lastY = 0;

// 선택한 색상
let currentColor = document.getElementById('colorPicker').value;
document.getElementById('colorPicker').addEventListener('input', (e) => {
  currentColor = e.target.value;
});

// 마우스 이벤트
canvas.addEventListener('mousedown', e => {
  drawing = true;
  [lastX, lastY] = [e.offsetX, e.offsetY];
});

canvas.addEventListener('mouseup', () => drawing = false);
canvas.addEventListener('mouseout', () => drawing = false);

canvas.addEventListener('mousemove', e => {
  if (!drawing) return;
  drawLine(lastX, lastY, e.offsetX, e.offsetY);
  [lastX, lastY] = [e.offsetX, e.offsetY];
});

// 터치 이벤트
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  drawing = true;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  lastX = touch.clientX - rect.left;
  lastY = touch.clientY - rect.top;
});

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  if (!drawing) return;
  const touch = e.touches[0];
  const rect = canvas.getBoundingClientRect();
  const x = touch.clientX - rect.left;
  const y = touch.clientY - rect.top;
  drawLine(lastX, lastY, x, y);
  lastX = x;
  lastY = y;
});

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  drawing = false;
});

// 선 그리기
function drawLine(x1, y1, x2, y2) {
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = 3;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(x1, y1);
  ctx.lineTo(x2, y2);
  ctx.stroke();
}

// 그림 저장
document.getElementById('saveButton').onclick = async () => {
  const imgData = canvas.toDataURL('image/png');

  await fetch("https://script.google.com/macros/s/AKfycbz4IdjipIivdWWQPDTmFL0hCTxRU_F5MbZfLVnwYcMMn0NelyM4Nwt5RgUV3oKE_Rv7/exec", {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded",
    },
    body: "imgdata=" + encodeURIComponent(imgData),
  });

  alert('그림이 저장되었습니다! (조금 기다렸다가 띄우는 화면 새로고침하세요)');
};
</script>

</body>
</html>
